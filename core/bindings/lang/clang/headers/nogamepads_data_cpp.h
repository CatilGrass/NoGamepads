// Auto generated by cbindgen 0.29.0

#ifndef NOGAMEPADS_DATA_H
#define NOGAMEPADS_DATA_H

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

enum class FfiConnectionMessageTag {
  ConnectionJoin,
  ConnectionRequestGameInfos,
  ConnectionRequestLayoutConfigure,
  ConnectionRequestSkinPackage,
  ConnectionReady,
  ConnectionError,
};

enum class FfiConnectionResponseMessageTag {
  GameInfosResponse,
  DenyResponse,
  FailResponse,
  OkResponse,
  WelcomeResponse,
  ErrorResponse,
};

enum class FfiControlMessageTag {
  CtrlMsg,
  CtrlPressed,
  CtrlReleased,
  CtrlAxis,
  CtrlDir,
  CtrlExit,
  CtrlError,
  CtrlEnd,
};

enum class FfiExitReason {
  ExitReason,
  GameOverReason,
  ServerClosedReason,
  YouAreKickedReason,
  YouAreBannedReason,
  ErrorReason,
};

enum class FfiGameMessageTag {
  GameEventTrigger,
  GameMsg,
  GameLetExit,
  GameError,
  GameEnd,
};

enum class FfiJoinFailedMessage {
  ContainIdenticalPlayer,
  PlayerBanned,
  GameLocked,
  UnknownError,
};

template<typename T = void>
struct ManuallyDrop;

struct FfiAccount {
  char *id;
  char *player_hash;
};

struct FfiCustomize {
  char *nickname;
  int color_hue;
  double color_saturation;
  double color_value;
};

struct FfiPlayer {
  FfiAccount account;
  FfiCustomize *customize;
};

struct FfiKeyAndAxis {
  uint8_t key;
  double axis;
};

struct FfiKeyAndDirection {
  uint8_t key;
  double x;
  double y;
};

union FfiControlMessageUnion {
  char *message;
  uint8_t key;
  ManuallyDrop<FfiKeyAndAxis> key_and_axis;
  ManuallyDrop<FfiKeyAndDirection> key_and_direction;
};

struct FfiControlMessage {
  FfiControlMessageTag tag;
  FfiControlMessageUnion data;
};

union FfiGameMessageUnion {
  uint8_t key;
  char *message;
  ManuallyDrop<FfiExitReason> exit_reason;
};

struct FfiGameMessage {
  FfiGameMessageTag tag;
  FfiGameMessageUnion data;
};

union FfiConnectionMessageUnion {
  ManuallyDrop<FfiPlayer> player;
};

struct FfiConnectionMessage {
  FfiConnectionMessageTag tag;
  FfiConnectionMessageUnion data;
};

struct KeyValuePair {
  char *key;
  char *value;
};

struct FfiGameInfo {
  KeyValuePair *data;
  uintptr_t len;
  uintptr_t cap;
};

union FfiConnectionResponseMessageUnion {
  ManuallyDrop<FfiGameInfo> game_info;
  ManuallyDrop<FfiJoinFailedMessage> failed_message;
};

struct FfiConnectionResponseMessage {
  FfiConnectionResponseMessageTag tag;
  FfiConnectionResponseMessageUnion data;
};

struct FfiControllerData {
  void *_0;
};

struct FfiControllerRuntime {
  void *inner;
  void (*drop_fn)(void*);
};

extern "C" {

void free_c_string(char *ptr);

/// Register a player
FfiPlayer *player_register(const char *id, const char *password);

/// Check if the player's password is correct
bool player_check(const FfiPlayer *player, const char *password);

/// Set the player's nickname
void player_set_nickname(FfiPlayer *player, const char *nickname);

/// Set the player's hue
void player_set_hue(FfiPlayer *player, int hue);

/// Set the player's HSV color
void player_set_hsv(FfiPlayer *player, int hue, double saturation, double value);

/// Free the player
void free_player(FfiPlayer *player);

/// Free ControlMessage
void free_control_message(FfiControlMessage msg);

/// Free GameMessage
void free_game_message(FfiGameMessage msg);

/// Free ExitReason
void free_exit_reason(FfiExitReason msg);

/// Free ConnectionMessage
void free_connection_message(FfiConnectionMessage msg);

/// Free ConnectionResponseMessage
void free_connection_response_message(FfiConnectionResponseMessage msg);

/// Free JoinFailedMessage
void free_join_failed_message(FfiJoinFailedMessage msg);

void free_game_info(FfiGameInfo map);

/// Create controller data
FfiControllerData *controller_data_new();

/// Bind player to controller
void controller_data_bind_player(FfiControllerData *controller, FfiPlayer *ffi_player);

/// Build runtime
FfiControllerRuntime *controller_data_build_runtime(FfiControllerData *controller);

/// Free ControllerData memory
void controller_data_free(FfiControllerData *controller);

/// Close runtime and exit game
void controller_runtime_close(FfiControllerRuntime *runtime);

/// Send control message
void controller_runtime_send_message(FfiControllerRuntime *runtime,
                                     FfiControlMessage *control_message);

/// Send text message
void controller_runtime_send_text_message(FfiControllerRuntime *runtime, const char *message_ptr);

/// Press a button
void controller_runtime_press_a_button(FfiControllerRuntime *runtime, uint8_t key);

/// Release a button
void controller_runtime_release_a_button(FfiControllerRuntime *runtime, uint8_t key);

/// Change axis value
void controller_runtime_change_axis(FfiControllerRuntime *runtime, uint8_t key, double axis);

/// Change direction value
void controller_runtime_change_direction(FfiControllerRuntime *runtime,
                                         uint8_t key,
                                         double x,
                                         double y);

/// Pop a message from the queue
FfiGameMessage *controller_runtime_pop(FfiControllerRuntime *runtime);

/// Free runtime memory
void controller_runtime_free(FfiControllerRuntime *runtime);

}  // extern "C"

#endif  // NOGAMEPADS_DATA_H
