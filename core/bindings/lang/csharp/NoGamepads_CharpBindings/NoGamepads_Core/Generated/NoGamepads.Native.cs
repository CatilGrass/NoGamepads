// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace NoGamepads_Sharp
{
    public enum FfiConnectionMessageTag
    {
        ConnectionJoin = 0,
        ConnectionRequestGameInfos = 1,
        ConnectionRequestLayoutConfigure = 2,
        ConnectionRequestSkinPackage = 3,
        ConnectionReady = 4,
        ConnectionError = 5
    }

    public enum FfiConnectionResponseMessageTag
    {
        GameInfosResponse = 0,
        DenyResponse = 1,
        FailResponse = 2,
        OkResponse = 3,
        WelcomeResponse = 4,
        ErrorResponse = 5
    }

    public enum FfiControlMessageTag
    {
        CtrlMsg = 0,
        CtrlPressed = 1,
        CtrlReleased = 2,
        CtrlAxis = 3,
        CtrlDir = 4,
        CtrlExit = 5,
        CtrlError = 6,
        CtrlEnd = 7
    }

    public enum FfiExitReason
    {
        ExitReason = 0,
        GameOverReason = 1,
        ServerClosedReason = 2,
        YouAreKickedReason = 3,
        YouAreBannedReason = 4,
        ErrorReason = 5
    }

    public enum FfiGameMessageTag
    {
        GameEventTrigger = 0,
        GameMsg = 1,
        GameLetExit = 2,
        GameError = 3,
        GameEnd = 4
    }

    public enum FfiJoinFailedMessage
    {
        ContainIdenticalPlayer = 0,
        PlayerBanned = 1,
        GameLocked = 2,
        UnknownError = 3
    }

    public enum FfiServiceType
    {
        Unknown = 0,
        TCPConnection = 1,
        BlueTooth = 2,
        USB = 3
    }

    public unsafe partial class FfiAccount : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr id;
            internal __IntPtr player_hash;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiAccount@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiAccount> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiAccount>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiAccount managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiAccount managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiAccount __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiAccount(native.ToPointer(), skipVTables);
        }

        internal static FfiAccount __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiAccount)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiAccount __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiAccount(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiAccount(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiAccount(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiAccount()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiAccount.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiAccount(global::NoGamepads_Sharp.FfiAccount _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiAccount.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiAccount.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiAccount.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Id
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = (__IntPtr) value;
            }
        }

        public sbyte* PlayerHash
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->player_hash;
            }

            set
            {
                ((__Internal*)__Instance)->player_hash = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiCustomize : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr nickname;
            internal int color_hue;
            internal double color_saturation;
            internal double color_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiCustomize@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiCustomize> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiCustomize>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiCustomize managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiCustomize managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiCustomize __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiCustomize(native.ToPointer(), skipVTables);
        }

        internal static FfiCustomize __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiCustomize)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiCustomize __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiCustomize(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiCustomize(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiCustomize(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiCustomize()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiCustomize.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiCustomize(global::NoGamepads_Sharp.FfiCustomize _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiCustomize.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiCustomize.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiCustomize.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Nickname
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->nickname;
            }

            set
            {
                ((__Internal*)__Instance)->nickname = (__IntPtr) value;
            }
        }

        public int ColorHue
        {
            get
            {
                return ((__Internal*)__Instance)->color_hue;
            }

            set
            {
                ((__Internal*)__Instance)->color_hue = value;
            }
        }

        public double ColorSaturation
        {
            get
            {
                return ((__Internal*)__Instance)->color_saturation;
            }

            set
            {
                ((__Internal*)__Instance)->color_saturation = value;
            }
        }

        public double ColorValue
        {
            get
            {
                return ((__Internal*)__Instance)->color_value;
            }

            set
            {
                ((__Internal*)__Instance)->color_value = value;
            }
        }
    }

    public unsafe partial class FfiPlayer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiAccount.__Internal account;
            internal __IntPtr customize;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiPlayer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiPlayer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiPlayer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiPlayer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiPlayer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiPlayer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiPlayer(native.ToPointer(), skipVTables);
        }

        internal static FfiPlayer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiPlayer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiPlayer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiPlayer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiPlayer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiPlayer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiPlayer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiPlayer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiPlayer(global::NoGamepads_Sharp.FfiPlayer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiPlayer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiPlayer.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiPlayer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiAccount Account
        {
            get
            {
                return global::NoGamepads_Sharp.FfiAccount.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->account));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->account = *(global::NoGamepads_Sharp.FfiAccount.__Internal*) value.__Instance;
            }
        }

        public global::NoGamepads_Sharp.FfiCustomize Customize
        {
            get
            {
                var __result0 = global::NoGamepads_Sharp.FfiCustomize.__GetOrCreateInstance(((__Internal*)__Instance)->customize, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->customize = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class FfiKeyAndAxis : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte key;
            internal double axis;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiKeyAndAxis@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiKeyAndAxis> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiKeyAndAxis>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiKeyAndAxis managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiKeyAndAxis managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiKeyAndAxis __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiKeyAndAxis(native.ToPointer(), skipVTables);
        }

        internal static FfiKeyAndAxis __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiKeyAndAxis)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiKeyAndAxis __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiKeyAndAxis(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiKeyAndAxis(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiKeyAndAxis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiKeyAndAxis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiKeyAndAxis(global::NoGamepads_Sharp.FfiKeyAndAxis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        public double Axis
        {
            get
            {
                return ((__Internal*)__Instance)->axis;
            }

            set
            {
                ((__Internal*)__Instance)->axis = value;
            }
        }
    }

    public unsafe partial class FfiKeyAndDirection : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte key;
            internal double x;
            internal double y;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiKeyAndDirection@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiKeyAndDirection> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiKeyAndDirection>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiKeyAndDirection managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiKeyAndDirection managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiKeyAndDirection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiKeyAndDirection(native.ToPointer(), skipVTables);
        }

        internal static FfiKeyAndDirection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiKeyAndDirection)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiKeyAndDirection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiKeyAndDirection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiKeyAndDirection(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiKeyAndDirection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiKeyAndDirection()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiKeyAndDirection(global::NoGamepads_Sharp.FfiKeyAndDirection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        public double X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public double Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial struct FfiControlMessageUnion
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr message;

            [FieldOffset(0)]
            internal byte key;

            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal key_and_axis;

            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal key_and_direction;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiControlMessageUnion@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private FfiControlMessageUnion.__Internal __instance;
        internal ref FfiControlMessageUnion.__Internal __Instance => ref __instance;

        internal static FfiControlMessageUnion __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FfiControlMessageUnion(native.ToPointer(), skipVTables);
        }

        internal static FfiControlMessageUnion __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiControlMessageUnion(native, skipVTables);
        }

        private FfiControlMessageUnion(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private FfiControlMessageUnion(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NoGamepads_Sharp.FfiControlMessageUnion.__Internal*) native;
        }

        public FfiControlMessageUnion(global::NoGamepads_Sharp.FfiControlMessageUnion _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public sbyte* Message
        {
            get
            {
                return (sbyte*) __instance.message;
            }

            set
            {
                __instance.message = (__IntPtr) value;
            }
        }

        public byte Key
        {
            get
            {
                return __instance.key;
            }

            set
            {
                __instance.key = value;
            }
        }

        public global::NoGamepads_Sharp.FfiKeyAndAxis KeyAndAxis
        {
            get
            {
                return global::NoGamepads_Sharp.FfiKeyAndAxis.__CreateInstance(__instance.key_and_axis);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.key_and_axis = *(global::NoGamepads_Sharp.FfiKeyAndAxis.__Internal*) value.__Instance;
            }
        }

        public global::NoGamepads_Sharp.FfiKeyAndDirection KeyAndDirection
        {
            get
            {
                return global::NoGamepads_Sharp.FfiKeyAndDirection.__CreateInstance(__instance.key_and_direction);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.key_and_direction = *(global::NoGamepads_Sharp.FfiKeyAndDirection.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class FfiControlMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiControlMessageTag tag;
            internal global::NoGamepads_Sharp.FfiControlMessageUnion.__Internal data;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiControlMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControlMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControlMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiControlMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiControlMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiControlMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiControlMessage(native.ToPointer(), skipVTables);
        }

        internal static FfiControlMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiControlMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiControlMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiControlMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiControlMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiControlMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiControlMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControlMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiControlMessage(global::NoGamepads_Sharp.FfiControlMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControlMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiControlMessage.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiControlMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiControlMessageTag Tag
        {
            get
            {
                return ((__Internal*)__Instance)->tag;
            }

            set
            {
                ((__Internal*)__Instance)->tag = value;
            }
        }

        public global::NoGamepads_Sharp.FfiControlMessageUnion Data
        {
            get
            {
                return global::NoGamepads_Sharp.FfiControlMessageUnion.__CreateInstance(((__Internal*)__Instance)->data);
            }

            set
            {
                ((__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    public unsafe partial struct FfiGameMessageUnion
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte key;

            [FieldOffset(0)]
            internal __IntPtr message;

            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiExitReason exit_reason;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameMessageUnion@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private FfiGameMessageUnion.__Internal __instance;
        internal ref FfiGameMessageUnion.__Internal __Instance => ref __instance;

        internal static FfiGameMessageUnion __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FfiGameMessageUnion(native.ToPointer(), skipVTables);
        }

        internal static FfiGameMessageUnion __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameMessageUnion(native, skipVTables);
        }

        private FfiGameMessageUnion(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private FfiGameMessageUnion(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NoGamepads_Sharp.FfiGameMessageUnion.__Internal*) native;
        }

        public FfiGameMessageUnion(global::NoGamepads_Sharp.FfiGameMessageUnion _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public byte Key
        {
            get
            {
                return __instance.key;
            }

            set
            {
                __instance.key = value;
            }
        }

        public sbyte* Message
        {
            get
            {
                return (sbyte*) __instance.message;
            }

            set
            {
                __instance.message = (__IntPtr) value;
            }
        }

        public global::NoGamepads_Sharp.FfiExitReason ExitReason
        {
            get
            {
                return __instance.exit_reason;
            }

            set
            {
                __instance.exit_reason = value;
            }
        }
    }

    public unsafe partial class FfiGameMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiGameMessageTag tag;
            internal global::NoGamepads_Sharp.FfiGameMessageUnion.__Internal data;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiGameMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiGameMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiGameMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiGameMessage(native.ToPointer(), skipVTables);
        }

        internal static FfiGameMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiGameMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiGameMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiGameMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiGameMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiGameMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiGameMessage(global::NoGamepads_Sharp.FfiGameMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiGameMessage.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiGameMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiGameMessageTag Tag
        {
            get
            {
                return ((__Internal*)__Instance)->tag;
            }

            set
            {
                ((__Internal*)__Instance)->tag = value;
            }
        }

        public global::NoGamepads_Sharp.FfiGameMessageUnion Data
        {
            get
            {
                return global::NoGamepads_Sharp.FfiGameMessageUnion.__CreateInstance(((__Internal*)__Instance)->data);
            }

            set
            {
                ((__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    public unsafe partial struct FfiConnectionMessageUnion
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiPlayer.__Internal player;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiConnectionMessageUnion@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private FfiConnectionMessageUnion.__Internal __instance;
        internal ref FfiConnectionMessageUnion.__Internal __Instance => ref __instance;

        internal static FfiConnectionMessageUnion __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FfiConnectionMessageUnion(native.ToPointer(), skipVTables);
        }

        internal static FfiConnectionMessageUnion __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiConnectionMessageUnion(native, skipVTables);
        }

        private FfiConnectionMessageUnion(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private FfiConnectionMessageUnion(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NoGamepads_Sharp.FfiConnectionMessageUnion.__Internal*) native;
        }

        public FfiConnectionMessageUnion(global::NoGamepads_Sharp.FfiConnectionMessageUnion _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public global::NoGamepads_Sharp.FfiPlayer Player
        {
            get
            {
                return global::NoGamepads_Sharp.FfiPlayer.__CreateInstance(__instance.player);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.player = *(global::NoGamepads_Sharp.FfiPlayer.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class FfiConnectionMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiConnectionMessageTag tag;
            internal global::NoGamepads_Sharp.FfiConnectionMessageUnion.__Internal data;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiConnectionMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiConnectionMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiConnectionMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiConnectionMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiConnectionMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiConnectionMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiConnectionMessage(native.ToPointer(), skipVTables);
        }

        internal static FfiConnectionMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiConnectionMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiConnectionMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiConnectionMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiConnectionMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiConnectionMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiConnectionMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiConnectionMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiConnectionMessage(global::NoGamepads_Sharp.FfiConnectionMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiConnectionMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiConnectionMessage.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiConnectionMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiConnectionMessageTag Tag
        {
            get
            {
                return ((__Internal*)__Instance)->tag;
            }

            set
            {
                ((__Internal*)__Instance)->tag = value;
            }
        }

        public global::NoGamepads_Sharp.FfiConnectionMessageUnion Data
        {
            get
            {
                return global::NoGamepads_Sharp.FfiConnectionMessageUnion.__CreateInstance(((__Internal*)__Instance)->data);
            }

            set
            {
                ((__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    public unsafe partial class KeyValuePair : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr value;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0KeyValuePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.KeyValuePair> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.KeyValuePair>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.KeyValuePair managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.KeyValuePair managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static KeyValuePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new KeyValuePair(native.ToPointer(), skipVTables);
        }

        internal static KeyValuePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (KeyValuePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static KeyValuePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new KeyValuePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private KeyValuePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected KeyValuePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public KeyValuePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.KeyValuePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public KeyValuePair(global::NoGamepads_Sharp.KeyValuePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.KeyValuePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.KeyValuePair.__Internal*) __Instance) = *((global::NoGamepads_Sharp.KeyValuePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Key
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = (__IntPtr) value;
            }
        }

        public sbyte* Value
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiGameInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal ulong len;
            internal ulong cap;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiGameInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiGameInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiGameInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiGameInfo(native.ToPointer(), skipVTables);
        }

        internal static FfiGameInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiGameInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiGameInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiGameInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiGameInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiGameInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiGameInfo(global::NoGamepads_Sharp.FfiGameInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiGameInfo.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiGameInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.KeyValuePair Data
        {
            get
            {
                var __result0 = global::NoGamepads_Sharp.KeyValuePair.__GetOrCreateInstance(((__Internal*)__Instance)->data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ulong Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        public ulong Cap
        {
            get
            {
                return ((__Internal*)__Instance)->cap;
            }

            set
            {
                ((__Internal*)__Instance)->cap = value;
            }
        }
    }

    public unsafe partial struct FfiConnectionResponseMessageUnion
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiGameInfo.__Internal game_info;

            [FieldOffset(0)]
            internal global::NoGamepads_Sharp.FfiJoinFailedMessage failed_message;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiConnectionResponseMessageUnion@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private FfiConnectionResponseMessageUnion.__Internal __instance;
        internal ref FfiConnectionResponseMessageUnion.__Internal __Instance => ref __instance;

        internal static FfiConnectionResponseMessageUnion __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FfiConnectionResponseMessageUnion(native.ToPointer(), skipVTables);
        }

        internal static FfiConnectionResponseMessageUnion __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiConnectionResponseMessageUnion(native, skipVTables);
        }

        private FfiConnectionResponseMessageUnion(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private FfiConnectionResponseMessageUnion(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NoGamepads_Sharp.FfiConnectionResponseMessageUnion.__Internal*) native;
        }

        public FfiConnectionResponseMessageUnion(global::NoGamepads_Sharp.FfiConnectionResponseMessageUnion _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public global::NoGamepads_Sharp.FfiGameInfo GameInfo
        {
            get
            {
                return global::NoGamepads_Sharp.FfiGameInfo.__CreateInstance(__instance.game_info);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.game_info = *(global::NoGamepads_Sharp.FfiGameInfo.__Internal*) value.__Instance;
            }
        }

        public global::NoGamepads_Sharp.FfiJoinFailedMessage FailedMessage
        {
            get
            {
                return __instance.failed_message;
            }

            set
            {
                __instance.failed_message = value;
            }
        }
    }

    public unsafe partial class FfiConnectionResponseMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiConnectionResponseMessageTag tag;
            internal global::NoGamepads_Sharp.FfiConnectionResponseMessageUnion.__Internal data;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiConnectionResponseMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiConnectionResponseMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiConnectionResponseMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiConnectionResponseMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiConnectionResponseMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiConnectionResponseMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiConnectionResponseMessage(native.ToPointer(), skipVTables);
        }

        internal static FfiConnectionResponseMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiConnectionResponseMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiConnectionResponseMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiConnectionResponseMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiConnectionResponseMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiConnectionResponseMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiConnectionResponseMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiConnectionResponseMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiConnectionResponseMessage(global::NoGamepads_Sharp.FfiConnectionResponseMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiConnectionResponseMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiConnectionResponseMessage.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiConnectionResponseMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiConnectionResponseMessageTag Tag
        {
            get
            {
                return ((__Internal*)__Instance)->tag;
            }

            set
            {
                ((__Internal*)__Instance)->tag = value;
            }
        }

        public global::NoGamepads_Sharp.FfiConnectionResponseMessageUnion Data
        {
            get
            {
                return global::NoGamepads_Sharp.FfiConnectionResponseMessageUnion.__CreateInstance(((__Internal*)__Instance)->data);
            }

            set
            {
                ((__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    public unsafe partial class FfiControllerData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr _0;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiControllerData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControllerData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControllerData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiControllerData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiControllerData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiControllerData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiControllerData(native.ToPointer(), skipVTables);
        }

        internal static FfiControllerData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiControllerData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiControllerData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiControllerData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiControllerData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiControllerData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiControllerData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControllerData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiControllerData(global::NoGamepads_Sharp.FfiControllerData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControllerData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiControllerData.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiControllerData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiControllerRuntime : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr inner;
            internal __IntPtr drop_fn;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiControllerRuntime@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControllerRuntime> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControllerRuntime>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiControllerRuntime managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiControllerRuntime managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiControllerRuntime __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiControllerRuntime(native.ToPointer(), skipVTables);
        }

        internal static FfiControllerRuntime __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiControllerRuntime)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiControllerRuntime __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiControllerRuntime(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiControllerRuntime(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiControllerRuntime(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiControllerRuntime()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControllerRuntime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiControllerRuntime(global::NoGamepads_Sharp.FfiControllerRuntime _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControllerRuntime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiControllerRuntime.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiControllerRuntime.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Inner
        {
            get
            {
                return ((__Internal*)__Instance)->inner;
            }

            set
            {
                ((__Internal*)__Instance)->inner = (__IntPtr) value;
            }
        }

        public global::NoGamepads_Sharp.Delegates.Action___IntPtr DropFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drop_fn;
                return __ptr0 == IntPtr.Zero? null : (global::NoGamepads_Sharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NoGamepads_Sharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->drop_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FfiGameData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr _0;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiGameData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiGameData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiGameData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiGameData(native.ToPointer(), skipVTables);
        }

        internal static FfiGameData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiGameData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiGameData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiGameData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiGameData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiGameData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiGameData(global::NoGamepads_Sharp.FfiGameData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiGameData.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiGameData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiGameRuntimeArchive : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr _0;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameRuntimeArchive@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameRuntimeArchive> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameRuntimeArchive>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiGameRuntimeArchive managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiGameRuntimeArchive managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiGameRuntimeArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiGameRuntimeArchive(native.ToPointer(), skipVTables);
        }

        internal static FfiGameRuntimeArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiGameRuntimeArchive)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiGameRuntimeArchive __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameRuntimeArchive(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiGameRuntimeArchive(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiGameRuntimeArchive(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiGameRuntimeArchive()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameRuntimeArchive.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiGameRuntimeArchive(global::NoGamepads_Sharp.FfiGameRuntimeArchive _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameRuntimeArchive.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiGameRuntimeArchive.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiGameRuntimeArchive.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiGameRuntime : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr inner;
            internal __IntPtr drop_fn;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiGameRuntime@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameRuntime> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiGameRuntime>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiGameRuntime managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiGameRuntime managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiGameRuntime __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiGameRuntime(native.ToPointer(), skipVTables);
        }

        internal static FfiGameRuntime __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiGameRuntime)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiGameRuntime __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiGameRuntime(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiGameRuntime(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiGameRuntime(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiGameRuntime()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameRuntime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiGameRuntime(global::NoGamepads_Sharp.FfiGameRuntime _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiGameRuntime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiGameRuntime.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiGameRuntime.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Inner
        {
            get
            {
                return ((__Internal*)__Instance)->inner;
            }

            set
            {
                ((__Internal*)__Instance)->inner = (__IntPtr) value;
            }
        }

        public global::NoGamepads_Sharp.Delegates.Action___IntPtr DropFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drop_fn;
                return __ptr0 == IntPtr.Zero? null : (global::NoGamepads_Sharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NoGamepads_Sharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->drop_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FfiControlEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::NoGamepads_Sharp.FfiPlayer.__Internal player;
            internal global::NoGamepads_Sharp.FfiControlMessage.__Internal message;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiControlEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControlEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiControlEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiControlEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiControlEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiControlEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiControlEvent(native.ToPointer(), skipVTables);
        }

        internal static FfiControlEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiControlEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiControlEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiControlEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiControlEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiControlEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiControlEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControlEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiControlEvent(global::NoGamepads_Sharp.FfiControlEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiControlEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiControlEvent.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiControlEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiPlayer Player
        {
            get
            {
                return global::NoGamepads_Sharp.FfiPlayer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->player));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->player = *(global::NoGamepads_Sharp.FfiPlayer.__Internal*) value.__Instance;
            }
        }

        public global::NoGamepads_Sharp.FfiControlMessage Message
        {
            get
            {
                return global::NoGamepads_Sharp.FfiControlMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->message));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->message = *(global::NoGamepads_Sharp.FfiControlMessage.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class FfiButtonStatus : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte found;
            internal byte pressed;
            internal byte released;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiButtonStatus@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiButtonStatus> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiButtonStatus>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiButtonStatus managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiButtonStatus managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiButtonStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiButtonStatus(native.ToPointer(), skipVTables);
        }

        internal static FfiButtonStatus __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiButtonStatus)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiButtonStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiButtonStatus(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiButtonStatus(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiButtonStatus(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiButtonStatus()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiButtonStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiButtonStatus(global::NoGamepads_Sharp.FfiButtonStatus _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiButtonStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiButtonStatus.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiButtonStatus.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Found
        {
            get
            {
                return ((__Internal*)__Instance)->found != 0;
            }

            set
            {
                ((__Internal*)__Instance)->found = (byte) (value ? 1 : 0);
            }
        }

        public bool Pressed
        {
            get
            {
                return ((__Internal*)__Instance)->pressed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pressed = (byte) (value ? 1 : 0);
            }
        }

        public bool Released
        {
            get
            {
                return ((__Internal*)__Instance)->released != 0;
            }

            set
            {
                ((__Internal*)__Instance)->released = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class FfiAxis : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte found;
            internal double axis;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiAxis@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiAxis> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiAxis>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiAxis managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiAxis managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiAxis __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiAxis(native.ToPointer(), skipVTables);
        }

        internal static FfiAxis __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiAxis)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiAxis __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiAxis(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiAxis(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiAxis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiAxis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiAxis.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiAxis(global::NoGamepads_Sharp.FfiAxis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiAxis.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiAxis.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiAxis.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Found
        {
            get
            {
                return ((__Internal*)__Instance)->found != 0;
            }

            set
            {
                ((__Internal*)__Instance)->found = (byte) (value ? 1 : 0);
            }
        }

        public double Axis
        {
            get
            {
                return ((__Internal*)__Instance)->axis;
            }

            set
            {
                ((__Internal*)__Instance)->axis = value;
            }
        }
    }

    public unsafe partial class FfiDirection : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte found;
            internal double x;
            internal double y;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiDirection@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiDirection> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiDirection>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiDirection managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiDirection managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiDirection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiDirection(native.ToPointer(), skipVTables);
        }

        internal static FfiDirection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiDirection)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiDirection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiDirection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiDirection(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiDirection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiDirection()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiDirection(global::NoGamepads_Sharp.FfiDirection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiDirection.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiDirection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Found
        {
            get
            {
                return ((__Internal*)__Instance)->found != 0;
            }

            set
            {
                ((__Internal*)__Instance)->found = (byte) (value ? 1 : 0);
            }
        }

        public double X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public double Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class FfiBooleanResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal byte found;
            internal byte result;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiBooleanResult@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiBooleanResult> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiBooleanResult>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiBooleanResult managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiBooleanResult managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiBooleanResult __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiBooleanResult(native.ToPointer(), skipVTables);
        }

        internal static FfiBooleanResult __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiBooleanResult)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiBooleanResult __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiBooleanResult(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiBooleanResult(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiBooleanResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiBooleanResult()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiBooleanResult.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiBooleanResult(global::NoGamepads_Sharp.FfiBooleanResult _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiBooleanResult.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiBooleanResult.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiBooleanResult.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Found
        {
            get
            {
                return ((__Internal*)__Instance)->found != 0;
            }

            set
            {
                ((__Internal*)__Instance)->found = (byte) (value ? 1 : 0);
            }
        }

        public bool Result
        {
            get
            {
                return ((__Internal*)__Instance)->result != 0;
            }

            set
            {
                ((__Internal*)__Instance)->result = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class FfiPlayerList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr players;
            internal ulong len;
            internal ulong cap;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiPlayerList@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiPlayerList> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiPlayerList>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiPlayerList managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiPlayerList managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiPlayerList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiPlayerList(native.ToPointer(), skipVTables);
        }

        internal static FfiPlayerList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiPlayerList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiPlayerList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiPlayerList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiPlayerList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiPlayerList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiPlayerList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiPlayerList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiPlayerList(global::NoGamepads_Sharp.FfiPlayerList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiPlayerList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiPlayerList.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiPlayerList.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NoGamepads_Sharp.FfiPlayer Players
        {
            get
            {
                var __result0 = global::NoGamepads_Sharp.FfiPlayer.__GetOrCreateInstance(((__Internal*)__Instance)->players, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->players = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ulong Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        public ulong Cap
        {
            get
            {
                return ((__Internal*)__Instance)->cap;
            }

            set
            {
                ((__Internal*)__Instance)->cap = value;
            }
        }
    }

    public unsafe partial class FfiTcpClientService : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr _0;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiTcpClientService@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiTcpClientService> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiTcpClientService>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiTcpClientService managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiTcpClientService managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiTcpClientService __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiTcpClientService(native.ToPointer(), skipVTables);
        }

        internal static FfiTcpClientService __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiTcpClientService)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiTcpClientService __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiTcpClientService(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiTcpClientService(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiTcpClientService(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiTcpClientService()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiTcpClientService.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiTcpClientService(global::NoGamepads_Sharp.FfiTcpClientService _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiTcpClientService.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiTcpClientService.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiTcpClientService.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FfiTcpServerService : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr _0;

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "??0FfiTcpServerService@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiTcpServerService> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NoGamepads_Sharp.FfiTcpServerService>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NoGamepads_Sharp.FfiTcpServerService managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NoGamepads_Sharp.FfiTcpServerService managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FfiTcpServerService __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FfiTcpServerService(native.ToPointer(), skipVTables);
        }

        internal static FfiTcpServerService __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FfiTcpServerService)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FfiTcpServerService __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FfiTcpServerService(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FfiTcpServerService(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FfiTcpServerService(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FfiTcpServerService()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiTcpServerService.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FfiTcpServerService(global::NoGamepads_Sharp.FfiTcpServerService _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NoGamepads_Sharp.FfiTcpServerService.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NoGamepads_Sharp.FfiTcpServerService.__Internal*) __Instance) = *((global::NoGamepads_Sharp.FfiTcpServerService.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class nogamepads_data
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_c_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeCString(sbyte* ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_register", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PlayerRegister([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_from_hash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PlayerFromHash([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hash);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_get_hash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PlayerGetHash(__IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_check", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlayerCheck(__IntPtr player, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_set_nickname", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PlayerSetNickname(__IntPtr player, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string nickname);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_set_hue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PlayerSetHue(__IntPtr player, int hue);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "player_set_hsv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PlayerSetHsv(__IntPtr player, int hue, double saturation, double value);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreePlayer(__IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_control_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeControlMessage(__IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_game_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeGameMessage(__IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_exit_reason", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeExitReason(global::NoGamepads_Sharp.FfiExitReason* msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_connection_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeConnectionMessage(__IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_connection_response_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeConnectionResponseMessage(__IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_join_failed_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeJoinFailedMessage(global::NoGamepads_Sharp.FfiJoinFailedMessage* msg);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_game_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeGameInfo(__IntPtr map);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_data_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ControllerDataNew();

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_data_bind_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerDataBindPlayer(__IntPtr controller, __IntPtr ffi_player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_data_build_runtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ControllerDataBuildRuntime(__IntPtr controller);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_controller_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeControllerData(__IntPtr controller);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeClose(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_send_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeSendMessage(__IntPtr runtime, __IntPtr control_message);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_send_text_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeSendTextMessage(__IntPtr runtime, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message_ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_press_a_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimePressAButton(__IntPtr runtime, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_release_a_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeReleaseAButton(__IntPtr runtime, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_change_axis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeChangeAxis(__IntPtr runtime, byte key, double axis);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_change_direction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ControllerRuntimeChangeDirection(__IntPtr runtime, byte key, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "controller_runtime_pop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ControllerRuntimePop(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_controller_runtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeControllerRuntime(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataNew();

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_add_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataAddInfo(__IntPtr data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_set_name_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataSetNameInfo(__IntPtr data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_set_version_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataSetVersionInfo(__IntPtr data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string version);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_load_archive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataLoadArchive(__IntPtr data, __IntPtr archive);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_data_build_runtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameDataBuildRuntime(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_game_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeGameData(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_archive_data_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameArchiveDataNew();

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_archive_data_add_ban_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameArchiveDataAddBanPlayer(__IntPtr data, __IntPtr ffi_player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_game_archive_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeGameArchiveData(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_send_message_to", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeSendMessageTo(__IntPtr runtime, __IntPtr player, __IntPtr message, global::NoGamepads_Sharp.FfiServiceType service_type);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_send_text_message", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeSendTextMessage(__IntPtr runtime, __IntPtr player, global::NoGamepads_Sharp.FfiServiceType service_type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_send_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeSendEvent(__IntPtr runtime, __IntPtr player, global::NoGamepads_Sharp.FfiServiceType service_type, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_pop_control_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GameRuntimePopControlEvent(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_let_exit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeLetExit(__IntPtr runtime, __IntPtr player, global::NoGamepads_Sharp.FfiServiceType service_type, global::NoGamepads_Sharp.FfiExitReason reason);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_kick_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeKickPlayer(__IntPtr runtime, __IntPtr player, global::NoGamepads_Sharp.FfiServiceType service_type);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_ban_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeBanPlayer(__IntPtr runtime, __IntPtr player, global::NoGamepads_Sharp.FfiServiceType service_type);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_pardon_player", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimePardonPlayer(__IntPtr runtime, __IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeClose(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_lock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeLock(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_unlock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeUnlock(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_lock_status", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GameRuntimeGetLockStatus(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_button_status", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeGetButtonStatus(__IntPtr @return, __IntPtr runtime, __IntPtr player, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_axis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeGetAxis(__IntPtr @return, __IntPtr runtime, __IntPtr player, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_direction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeGetDirection(__IntPtr @return, __IntPtr runtime, __IntPtr player, byte key);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_service_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::NoGamepads_Sharp.FfiServiceType GameRuntimeGetServiceType(__IntPtr runtime, __IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_is_player_banned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::NoGamepads_Sharp.FfiBooleanResult.__Internal GameRuntimeIsPlayerBanned(__IntPtr runtime, __IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_is_player_online", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::NoGamepads_Sharp.FfiBooleanResult.__Internal GameRuntimeIsPlayerOnline(__IntPtr runtime, __IntPtr player);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_online_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeGetOnlineList(__IntPtr @return, __IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "game_runtime_get_banned_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GameRuntimeGetBannedList(__IntPtr @return, __IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_game_runtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeGameRuntime(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_control_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeControlEvent(__IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_player_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreePlayerList(__IntPtr list);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_ffi_service_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeFfiServiceType(global::NoGamepads_Sharp.FfiServiceType* ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_build", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr TcpClientBuild(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_bind_ipv4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpClientBindIpv4(__IntPtr service, byte a0, byte a1, byte a2, byte a3);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_bind_ipv6", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TcpClientBindIpv6(__IntPtr service, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ip_str);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_bind_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpClientBindPort(__IntPtr service, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_bind_address_v4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpClientBindAddressV4(__IntPtr service, byte a0, byte a1, byte a2, byte a3, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_bind_address_v6", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TcpClientBindAddressV6(__IntPtr service, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ip_str, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_client_connect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpClientConnect(__IntPtr service);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_tcp_client", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeTcpClient(__IntPtr service);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_build", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr TcpServerBuild(__IntPtr runtime);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_bind_ipv4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpServerBindIpv4(__IntPtr service, byte a0, byte a1, byte a2, byte a3);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_bind_ipv6", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TcpServerBindIpv6(__IntPtr service, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ip_str);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_bind_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpServerBindPort(__IntPtr service, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_bind_address_v4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpServerBindAddressV4(__IntPtr service, byte a0, byte a1, byte a2, byte a3, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_bind_address_v6", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TcpServerBindAddressV6(__IntPtr service, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ip_str, ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "tcp_server_listening_block_on", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TcpServerListeningBlockOn(__IntPtr service);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "free_tcp_server", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FreeTcpServer(__IntPtr service);

            [SuppressUnmanagedCodeSecurity, DllImport("NoGamepads.Native.dll", EntryPoint = "enable_logger", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void EnableLogger(byte level);
        }

        public static void FreeCString(sbyte* ptr)
        {
            __Internal.FreeCString(ptr);
        }

        /// <summary>Register a player</summary>
        public static global::NoGamepads_Sharp.FfiPlayer PlayerRegister(string id, string password)
        {
            var ___ret = __Internal.PlayerRegister(id, password);
            var __result0 = global::NoGamepads_Sharp.FfiPlayer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Register a player from hash</summary>
        public static global::NoGamepads_Sharp.FfiPlayer PlayerFromHash(string hash)
        {
            var ___ret = __Internal.PlayerFromHash(hash);
            var __result0 = global::NoGamepads_Sharp.FfiPlayer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a hash from player</summary>
        public static string PlayerGetHash(global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = __Internal.PlayerGetHash(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Check if the player's password is correct</summary>
        public static bool PlayerCheck(global::NoGamepads_Sharp.FfiPlayer player, string password)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = __Internal.PlayerCheck(__arg0, password);
            return ___ret;
        }

        /// <summary>Set the player's nickname</summary>
        public static void PlayerSetNickname(global::NoGamepads_Sharp.FfiPlayer player, string nickname)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.PlayerSetNickname(__arg0, nickname);
        }

        /// <summary>Set the player's hue</summary>
        public static void PlayerSetHue(global::NoGamepads_Sharp.FfiPlayer player, int hue)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.PlayerSetHue(__arg0, hue);
        }

        /// <summary>Set the player's HSV color</summary>
        public static void PlayerSetHsv(global::NoGamepads_Sharp.FfiPlayer player, int hue, double saturation, double value)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.PlayerSetHsv(__arg0, hue, saturation, value);
        }

        /// <summary>Free the player</summary>
        public static void FreePlayer(global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.FreePlayer(__arg0);
        }

        /// <summary>Free ControlMessage</summary>
        public static void FreeControlMessage(global::NoGamepads_Sharp.FfiControlMessage msg)
        {
            var __arg0 = msg is null ? __IntPtr.Zero : msg.__Instance;
            __Internal.FreeControlMessage(__arg0);
        }

        /// <summary>Free GameMessage</summary>
        public static void FreeGameMessage(global::NoGamepads_Sharp.FfiGameMessage msg)
        {
            var __arg0 = msg is null ? __IntPtr.Zero : msg.__Instance;
            __Internal.FreeGameMessage(__arg0);
        }

        /// <summary>Free ExitReason</summary>
        public static void FreeExitReason(ref global::NoGamepads_Sharp.FfiExitReason msg)
        {
            fixed (global::NoGamepads_Sharp.FfiExitReason* __msg0 = &msg)
            {
                var __arg0 = __msg0;
                __Internal.FreeExitReason(__arg0);
            }
        }

        /// <summary>Free ConnectionMessage</summary>
        public static void FreeConnectionMessage(global::NoGamepads_Sharp.FfiConnectionMessage msg)
        {
            var __arg0 = msg is null ? __IntPtr.Zero : msg.__Instance;
            __Internal.FreeConnectionMessage(__arg0);
        }

        /// <summary>Free ConnectionResponseMessage</summary>
        public static void FreeConnectionResponseMessage(global::NoGamepads_Sharp.FfiConnectionResponseMessage msg)
        {
            var __arg0 = msg is null ? __IntPtr.Zero : msg.__Instance;
            __Internal.FreeConnectionResponseMessage(__arg0);
        }

        /// <summary>Free JoinFailedMessage</summary>
        public static void FreeJoinFailedMessage(ref global::NoGamepads_Sharp.FfiJoinFailedMessage msg)
        {
            fixed (global::NoGamepads_Sharp.FfiJoinFailedMessage* __msg0 = &msg)
            {
                var __arg0 = __msg0;
                __Internal.FreeJoinFailedMessage(__arg0);
            }
        }

        public static void FreeGameInfo(global::NoGamepads_Sharp.FfiGameInfo map)
        {
            if (ReferenceEquals(map, null))
                throw new global::System.ArgumentNullException("map", "Cannot be null because it is passed by value.");
            var __arg0 = map.__Instance;
            __Internal.FreeGameInfo(__arg0);
        }

        /// <summary>Create controller data</summary>
        public static global::NoGamepads_Sharp.FfiControllerData ControllerDataNew()
        {
            var ___ret = __Internal.ControllerDataNew();
            var __result0 = global::NoGamepads_Sharp.FfiControllerData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind player to controller</summary>
        public static void ControllerDataBindPlayer(global::NoGamepads_Sharp.FfiControllerData controller, global::NoGamepads_Sharp.FfiPlayer ffi_player)
        {
            var __arg0 = controller is null ? __IntPtr.Zero : controller.__Instance;
            var __arg1 = ffi_player is null ? __IntPtr.Zero : ffi_player.__Instance;
            __Internal.ControllerDataBindPlayer(__arg0, __arg1);
        }

        /// <summary>Build runtime</summary>
        public static global::NoGamepads_Sharp.FfiControllerRuntime ControllerDataBuildRuntime(global::NoGamepads_Sharp.FfiControllerData controller)
        {
            var __arg0 = controller is null ? __IntPtr.Zero : controller.__Instance;
            var ___ret = __Internal.ControllerDataBuildRuntime(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiControllerRuntime.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free ControllerData memory</summary>
        public static void FreeControllerData(global::NoGamepads_Sharp.FfiControllerData controller)
        {
            var __arg0 = controller is null ? __IntPtr.Zero : controller.__Instance;
            __Internal.FreeControllerData(__arg0);
        }

        /// <summary>Close runtime and exit game</summary>
        public static void ControllerRuntimeClose(global::NoGamepads_Sharp.FfiControllerRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimeClose(__arg0);
        }

        /// <summary>Send control message</summary>
        public static void ControllerRuntimeSendMessage(global::NoGamepads_Sharp.FfiControllerRuntime runtime, global::NoGamepads_Sharp.FfiControlMessage control_message)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = control_message is null ? __IntPtr.Zero : control_message.__Instance;
            __Internal.ControllerRuntimeSendMessage(__arg0, __arg1);
        }

        /// <summary>Send text message</summary>
        public static void ControllerRuntimeSendTextMessage(global::NoGamepads_Sharp.FfiControllerRuntime runtime, string message_ptr)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimeSendTextMessage(__arg0, message_ptr);
        }

        /// <summary>Press a button</summary>
        public static void ControllerRuntimePressAButton(global::NoGamepads_Sharp.FfiControllerRuntime runtime, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimePressAButton(__arg0, key);
        }

        /// <summary>Release a button</summary>
        public static void ControllerRuntimeReleaseAButton(global::NoGamepads_Sharp.FfiControllerRuntime runtime, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimeReleaseAButton(__arg0, key);
        }

        /// <summary>Change axis value</summary>
        public static void ControllerRuntimeChangeAxis(global::NoGamepads_Sharp.FfiControllerRuntime runtime, byte key, double axis)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimeChangeAxis(__arg0, key, axis);
        }

        /// <summary>Change direction value</summary>
        public static void ControllerRuntimeChangeDirection(global::NoGamepads_Sharp.FfiControllerRuntime runtime, byte key, double x, double y)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.ControllerRuntimeChangeDirection(__arg0, key, x, y);
        }

        /// <summary>Pop a message from the queue</summary>
        public static global::NoGamepads_Sharp.FfiGameMessage ControllerRuntimePop(global::NoGamepads_Sharp.FfiControllerRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = __Internal.ControllerRuntimePop(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiGameMessage.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free runtime memory</summary>
        public static void FreeControllerRuntime(global::NoGamepads_Sharp.FfiControllerRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.FreeControllerRuntime(__arg0);
        }

        /// <summary>Create game data</summary>
        public static global::NoGamepads_Sharp.FfiGameData GameDataNew()
        {
            var ___ret = __Internal.GameDataNew();
            var __result0 = global::NoGamepads_Sharp.FfiGameData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add info</summary>
        public static global::NoGamepads_Sharp.FfiGameData GameDataAddInfo(global::NoGamepads_Sharp.FfiGameData data, string key, string value)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var ___ret = __Internal.GameDataAddInfo(__arg0, key, value);
            var __result0 = global::NoGamepads_Sharp.FfiGameData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set name info</summary>
        public static global::NoGamepads_Sharp.FfiGameData GameDataSetNameInfo(global::NoGamepads_Sharp.FfiGameData data, string name)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var ___ret = __Internal.GameDataSetNameInfo(__arg0, name);
            var __result0 = global::NoGamepads_Sharp.FfiGameData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set version info</summary>
        public static global::NoGamepads_Sharp.FfiGameData GameDataSetVersionInfo(global::NoGamepads_Sharp.FfiGameData data, string version)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var ___ret = __Internal.GameDataSetVersionInfo(__arg0, version);
            var __result0 = global::NoGamepads_Sharp.FfiGameData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Load data archive</summary>
        public static global::NoGamepads_Sharp.FfiGameData GameDataLoadArchive(global::NoGamepads_Sharp.FfiGameData data, global::NoGamepads_Sharp.FfiGameRuntimeArchive archive)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var __arg1 = archive is null ? __IntPtr.Zero : archive.__Instance;
            var ___ret = __Internal.GameDataLoadArchive(__arg0, __arg1);
            var __result0 = global::NoGamepads_Sharp.FfiGameData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Build runtime by data</summary>
        public static global::NoGamepads_Sharp.FfiGameRuntime GameDataBuildRuntime(global::NoGamepads_Sharp.FfiGameData data)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var ___ret = __Internal.GameDataBuildRuntime(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiGameRuntime.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free data</summary>
        public static void FreeGameData(global::NoGamepads_Sharp.FfiGameData data)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            __Internal.FreeGameData(__arg0);
        }

        /// <summary>Create game archive data</summary>
        public static global::NoGamepads_Sharp.FfiGameRuntimeArchive GameArchiveDataNew()
        {
            var ___ret = __Internal.GameArchiveDataNew();
            var __result0 = global::NoGamepads_Sharp.FfiGameRuntimeArchive.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add ban player</summary>
        public static global::NoGamepads_Sharp.FfiGameRuntimeArchive GameArchiveDataAddBanPlayer(global::NoGamepads_Sharp.FfiGameRuntimeArchive data, global::NoGamepads_Sharp.FfiPlayer ffi_player)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var __arg1 = ffi_player is null ? __IntPtr.Zero : ffi_player.__Instance;
            var ___ret = __Internal.GameArchiveDataAddBanPlayer(__arg0, __arg1);
            var __result0 = global::NoGamepads_Sharp.FfiGameRuntimeArchive.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free data</summary>
        public static void FreeGameArchiveData(global::NoGamepads_Sharp.FfiGameRuntimeArchive data)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            __Internal.FreeGameArchiveData(__arg0);
        }

        /// <summary>Send a message to</summary>
        public static void GameRuntimeSendMessageTo(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiGameMessage message, global::NoGamepads_Sharp.FfiServiceType service_type)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var __arg2 = message is null ? __IntPtr.Zero : message.__Instance;
            __Internal.GameRuntimeSendMessageTo(__arg0, __arg1, __arg2, service_type);
        }

        /// <summary>Send a text message</summary>
        public static void GameRuntimeSendTextMessage(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiServiceType service_type, string text)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimeSendTextMessage(__arg0, __arg1, service_type, text);
        }

        /// <summary>Send a event message</summary>
        public static void GameRuntimeSendEvent(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiServiceType service_type, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimeSendEvent(__arg0, __arg1, service_type, key);
        }

        /// <summary>Pop a control event</summary>
        public static global::NoGamepads_Sharp.FfiControlEvent GameRuntimePopControlEvent(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = __Internal.GameRuntimePopControlEvent(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiControlEvent.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Let player exit</summary>
        public static void GameRuntimeLetExit(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiServiceType service_type, global::NoGamepads_Sharp.FfiExitReason reason)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimeLetExit(__arg0, __arg1, service_type, reason);
        }

        /// <summary>Kick a player</summary>
        public static void GameRuntimeKickPlayer(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiServiceType service_type)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimeKickPlayer(__arg0, __arg1, service_type);
        }

        /// <summary>Ban a player (And kick)</summary>
        public static void GameRuntimeBanPlayer(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, global::NoGamepads_Sharp.FfiServiceType service_type)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimeBanPlayer(__arg0, __arg1, service_type);
        }

        /// <summary>Pardon a player</summary>
        public static void GameRuntimePardonPlayer(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            __Internal.GameRuntimePardonPlayer(__arg0, __arg1);
        }

        /// <summary>Close runtime</summary>
        public static void GameRuntimeClose(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.GameRuntimeClose(__arg0);
        }

        /// <summary>Lock game</summary>
        public static void GameRuntimeLock(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.GameRuntimeLock(__arg0);
        }

        /// <summary>Unlock game</summary>
        public static void GameRuntimeUnlock(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.GameRuntimeUnlock(__arg0);
        }

        /// <summary>Get game lock status</summary>
        public static bool GameRuntimeGetLockStatus(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = __Internal.GameRuntimeGetLockStatus(__arg0);
            return ___ret;
        }

        /// <summary>Get button status of player</summary>
        public static global::NoGamepads_Sharp.FfiButtonStatus GameRuntimeGetButtonStatus(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = new global::NoGamepads_Sharp.FfiButtonStatus.__Internal();
            __Internal.GameRuntimeGetButtonStatus(new IntPtr(&___ret), __arg0, __arg1, key);
            return global::NoGamepads_Sharp.FfiButtonStatus.__CreateInstance(___ret);
        }

        /// <summary>Get axis value of player</summary>
        public static global::NoGamepads_Sharp.FfiAxis GameRuntimeGetAxis(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = new global::NoGamepads_Sharp.FfiAxis.__Internal();
            __Internal.GameRuntimeGetAxis(new IntPtr(&___ret), __arg0, __arg1, key);
            return global::NoGamepads_Sharp.FfiAxis.__CreateInstance(___ret);
        }

        /// <summary>Get direction value of player</summary>
        public static global::NoGamepads_Sharp.FfiDirection GameRuntimeGetDirection(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player, byte key)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = new global::NoGamepads_Sharp.FfiDirection.__Internal();
            __Internal.GameRuntimeGetDirection(new IntPtr(&___ret), __arg0, __arg1, key);
            return global::NoGamepads_Sharp.FfiDirection.__CreateInstance(___ret);
        }

        /// <summary>Get service type of player</summary>
        public static global::NoGamepads_Sharp.FfiServiceType GameRuntimeGetServiceType(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = __Internal.GameRuntimeGetServiceType(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Is player banned</summary>
        public static global::NoGamepads_Sharp.FfiBooleanResult GameRuntimeIsPlayerBanned(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = __Internal.GameRuntimeIsPlayerBanned(__arg0, __arg1);
            return global::NoGamepads_Sharp.FfiBooleanResult.__CreateInstance(___ret);
        }

        /// <summary>Is player online</summary>
        public static global::NoGamepads_Sharp.FfiBooleanResult GameRuntimeIsPlayerOnline(global::NoGamepads_Sharp.FfiGameRuntime runtime, global::NoGamepads_Sharp.FfiPlayer player)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var __arg1 = player is null ? __IntPtr.Zero : player.__Instance;
            var ___ret = __Internal.GameRuntimeIsPlayerOnline(__arg0, __arg1);
            return global::NoGamepads_Sharp.FfiBooleanResult.__CreateInstance(___ret);
        }

        /// <summary>Get online list</summary>
        public static global::NoGamepads_Sharp.FfiPlayerList GameRuntimeGetOnlineList(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = new global::NoGamepads_Sharp.FfiPlayerList.__Internal();
            __Internal.GameRuntimeGetOnlineList(new IntPtr(&___ret), __arg0);
            return global::NoGamepads_Sharp.FfiPlayerList.__CreateInstance(___ret);
        }

        /// <summary>Get banned list</summary>
        public static global::NoGamepads_Sharp.FfiPlayerList GameRuntimeGetBannedList(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = new global::NoGamepads_Sharp.FfiPlayerList.__Internal();
            __Internal.GameRuntimeGetBannedList(new IntPtr(&___ret), __arg0);
            return global::NoGamepads_Sharp.FfiPlayerList.__CreateInstance(___ret);
        }

        /// <summary>Free game runtime</summary>
        public static void FreeGameRuntime(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            __Internal.FreeGameRuntime(__arg0);
        }

        /// <summary>Free control event</summary>
        public static void FreeControlEvent(global::NoGamepads_Sharp.FfiControlEvent @event)
        {
            var __arg0 = @event is null ? __IntPtr.Zero : @event.__Instance;
            __Internal.FreeControlEvent(__arg0);
        }

        /// <summary>Free player list</summary>
        public static void FreePlayerList(global::NoGamepads_Sharp.FfiPlayerList list)
        {
            if (ReferenceEquals(list, null))
                throw new global::System.ArgumentNullException("list", "Cannot be null because it is passed by value.");
            var __arg0 = list.__Instance;
            __Internal.FreePlayerList(__arg0);
        }

        /// <summary>Free service type tag</summary>
        public static void FreeFfiServiceType(ref global::NoGamepads_Sharp.FfiServiceType ptr)
        {
            fixed (global::NoGamepads_Sharp.FfiServiceType* __ptr0 = &ptr)
            {
                var __arg0 = __ptr0;
                __Internal.FreeFfiServiceType(__arg0);
            }
        }

        /// <summary>Build tcp client</summary>
        public static global::NoGamepads_Sharp.FfiTcpClientService TcpClientBuild(global::NoGamepads_Sharp.FfiControllerRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = __Internal.TcpClientBuild(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiTcpClientService.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind ipv4 address</summary>
        public static void TcpClientBindIpv4(global::NoGamepads_Sharp.FfiTcpClientService service, byte a0, byte a1, byte a2, byte a3)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpClientBindIpv4(__arg0, a0, a1, a2, a3);
        }

        /// <summary>Bind ipv6 address</summary>
        public static bool TcpClientBindIpv6(global::NoGamepads_Sharp.FfiTcpClientService service, string ip_str)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            var ___ret = __Internal.TcpClientBindIpv6(__arg0, ip_str);
            return ___ret;
        }

        /// <summary>Bind port</summary>
        public static void TcpClientBindPort(global::NoGamepads_Sharp.FfiTcpClientService service, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpClientBindPort(__arg0, port);
        }

        /// <summary>Bind address with ipv4</summary>
        public static void TcpClientBindAddressV4(global::NoGamepads_Sharp.FfiTcpClientService service, byte a0, byte a1, byte a2, byte a3, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpClientBindAddressV4(__arg0, a0, a1, a2, a3, port);
        }

        /// <summary>Bind address with ipv6</summary>
        public static bool TcpClientBindAddressV6(global::NoGamepads_Sharp.FfiTcpClientService service, string ip_str, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            var ___ret = __Internal.TcpClientBindAddressV6(__arg0, ip_str, port);
            return ___ret;
        }

        /// <summary>Connect</summary>
        public static void TcpClientConnect(global::NoGamepads_Sharp.FfiTcpClientService service)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpClientConnect(__arg0);
        }

        /// <summary>Free tcp client</summary>
        public static void FreeTcpClient(global::NoGamepads_Sharp.FfiTcpClientService service)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.FreeTcpClient(__arg0);
        }

        /// <summary>Build tcp server</summary>
        public static global::NoGamepads_Sharp.FfiTcpServerService TcpServerBuild(global::NoGamepads_Sharp.FfiGameRuntime runtime)
        {
            var __arg0 = runtime is null ? __IntPtr.Zero : runtime.__Instance;
            var ___ret = __Internal.TcpServerBuild(__arg0);
            var __result0 = global::NoGamepads_Sharp.FfiTcpServerService.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind ipv4 address</summary>
        public static void TcpServerBindIpv4(global::NoGamepads_Sharp.FfiTcpServerService service, byte a0, byte a1, byte a2, byte a3)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpServerBindIpv4(__arg0, a0, a1, a2, a3);
        }

        /// <summary>Bind ipv6 address</summary>
        public static bool TcpServerBindIpv6(global::NoGamepads_Sharp.FfiTcpServerService service, string ip_str)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            var ___ret = __Internal.TcpServerBindIpv6(__arg0, ip_str);
            return ___ret;
        }

        /// <summary>Bind port</summary>
        public static void TcpServerBindPort(global::NoGamepads_Sharp.FfiTcpServerService service, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpServerBindPort(__arg0, port);
        }

        /// <summary>Bind address with ipv4</summary>
        public static void TcpServerBindAddressV4(global::NoGamepads_Sharp.FfiTcpServerService service, byte a0, byte a1, byte a2, byte a3, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpServerBindAddressV4(__arg0, a0, a1, a2, a3, port);
        }

        /// <summary>Bind address with ipv6</summary>
        public static bool TcpServerBindAddressV6(global::NoGamepads_Sharp.FfiTcpServerService service, string ip_str, ushort port)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            var ___ret = __Internal.TcpServerBindAddressV6(__arg0, ip_str, port);
            return ___ret;
        }

        /// <summary>Start listening</summary>
        public static void TcpServerListeningBlockOn(global::NoGamepads_Sharp.FfiTcpServerService service)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.TcpServerListeningBlockOn(__arg0);
        }

        /// <summary>Free tcp server</summary>
        public static void FreeTcpServer(global::NoGamepads_Sharp.FfiTcpServerService service)
        {
            var __arg0 = service is null ? __IntPtr.Zero : service.__Instance;
            __Internal.FreeTcpServer(__arg0);
        }

        public static void EnableLogger(byte level)
        {
            __Internal.EnableLogger(level);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr __0);
    }
}
